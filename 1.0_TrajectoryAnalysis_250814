---
title: "250814_TrajectoryAnalysis"
author: "Matthew Luchs"
date: "2025-08-14"
output: html_document
---

```{r}

# Fixed TradeSeq Analysis function
perform_tradeseq_analysis <- function(seurat_obj,
                                    subset_name = "tradeseq_analysis",
                                    target_clusters = NULL,
                                    start_cluster = NULL,
                                    end_clusters = NULL,
                                    reduction = "umap",
                                    cluster_column = "seurat_clusters",
                                    n_knots = 6,
                                    min_gene_expression = 0.1,
                                    min_cells_expressing = 0.05,
                                    output_dir = "/home/matthew/data") {
  
  # Load required libraries with error checking
  required_packages <- c("Seurat", "SingleCellExperiment", "tradeSeq", 
                        "dplyr", "ggplot2", "viridis", "pheatmap", 
                        "patchwork", "readr", "stringr")
  
  for (pkg in required_packages) {
    if (!require(pkg, character.only = TRUE, quietly = TRUE)) {
      stop(paste("Required package", pkg, "is not installed. Please install it first."))
    }
  }
  
  cat("=== TRADESEQ TRAJECTORY ANALYSIS ===\n")
  cat("Subset:", subset_name, "\n")
  
  # Step 1: Extract subset if specified
  if (!is.null(target_clusters)) {
    # Ensure target_clusters are character type to match Seurat clusters
    target_clusters <- as.character(target_clusters)
    Idents(seurat_obj) <- cluster_column
    
    # Check if all target clusters exist
    available_clusters <- levels(Idents(seurat_obj))
    missing_clusters <- setdiff(target_clusters, available_clusters)
    if (length(missing_clusters) > 0) {
      warning(paste("Clusters not found:", paste(missing_clusters, collapse = ", ")))
      target_clusters <- intersect(target_clusters, available_clusters)
    }
    
    if (length(target_clusters) == 0) {
      stop("No valid target clusters found!")
    }
    
    subset_obj <- subset(seurat_obj, idents = target_clusters)
    cat("Analyzing clusters:", paste(target_clusters, collapse = ", "), "\n")
  } else {
    subset_obj <- seurat_obj
    cat("Analyzing all cells\n")
  }
  
  cat("Total cells in analysis:", ncol(subset_obj), "\n")
  
  # Check if we have enough cells
  if (ncol(subset_obj) < 50) {
    stop("Too few cells for trajectory analysis (minimum 50 recommended)")
  }
  
  # Step 2: Convert to SingleCellExperiment with error handling
  tryCatch({
    sce <- as.SingleCellExperiment(subset_obj)
  }, error = function(e) {
    stop(paste("Failed to convert to SingleCellExperiment:", e$message))
  })
  
  # Get coordinates for trajectory fitting
  if (reduction == "umap") {
    if (!"umap" %in% names(subset_obj@reductions)) {
      stop("UMAP reduction not found in Seurat object. Run RunUMAP first.")
    }
    coords <- subset_obj@reductions$umap@cell.embeddings
    cat("Using UMAP coordinates: ", nrow(coords), " cells x ", ncol(coords), " dimensions\n")
  } else if (reduction == "pca") {
    if (!"pca" %in% names(subset_obj@reductions)) {
      stop("PCA reduction not found in Seurat object. Run RunPCA first.")
    }
    coords <- subset_obj@reductions$pca@cell.embeddings[,1:min(20, ncol(subset_obj@reductions$pca@cell.embeddings))]
    cat("Using PCA coordinates: ", nrow(coords), " cells x ", ncol(coords), " dimensions\n")
  } else {
    stop("Reduction must be 'umap' or 'pca'")
  }
  
  # Ensure coords is a matrix and has the expected structure
  if (!is.matrix(coords)) {
    coords <- as.matrix(coords)
  }
  
  # Check for any issues with the coordinates
  if (any(is.na(coords))) {
    stop("NA values found in reduction coordinates")
  }
  
  if (any(is.infinite(coords))) {
    stop("Infinite values found in reduction coordinates")
  }
  
  # Step 3: Fit initial trajectory using slingshot (simple version)
  cat("Fitting trajectory with slingshot...\n")
  
  # Add coordinates to SCE
  reducedDim(sce, "coords") <- coords
  
  # Get cluster information - ensure it's a factor
  clusters <- as.factor(colData(sce)[[cluster_column]])
  if (any(is.na(clusters))) {
    stop(paste("Missing cluster information in column:", cluster_column))
  }
  
  cluster_centers <- aggregate(coords, by = list(clusters), FUN = mean)
  names(cluster_centers)[1] <- "cluster"
  
  # Create a simple pseudotime based on progression through clusters
  # Order clusters by their position along first component
  cluster_order <- cluster_centers[order(cluster_centers[,2]), "cluster"]
  
  # If start cluster specified, reorder
  if (!is.null(start_cluster)) {
    start_cluster <- as.character(start_cluster)  # Ensure character type
    start_idx <- which(cluster_order == start_cluster)
    if (length(start_idx) > 0) {
      cluster_order <- c(cluster_order[start_idx:length(cluster_order)], 
                        cluster_order[1:(start_idx-1)])
    } else {
      warning(paste("Start cluster", start_cluster, "not found in data"))
    }
  }
  
  # Assign pseudotime based on cluster order and position within cluster
  pseudotime <- numeric(ncol(sce))
  names(pseudotime) <- colnames(sce)
  
  for (i in seq_along(cluster_order)) {
  cluster_cells <- clusters == cluster_order[i]
  if (sum(cluster_cells) > 0) {
    # Base pseudotime for this cluster
    base_time <- (i - 1) / (length(cluster_order) - 1)
    
    # Add within-cluster variation based on position along trajectory
    if (sum(cluster_cells) > 1) {
      cluster_coords <- coords[cluster_cells, , drop = FALSE]
      
      # DEBUG
      cat("Cluster", cluster_order[i], ":\n")
      cat("  coords dimensions:", dim(coords), "\n")
      cat("  cluster_cells sum:", sum(cluster_cells), "\n")
      cat("  cluster_coords dimensions:", dim(cluster_coords), "\n")
      cat("  Weight vector:", c(1, 0.1), "\n")
      
      # This is where it fails
      pc1_proj <- cluster_coords %*% c(1, 0.1)
      #pc1_proj <- cluster_coords %*% c(1, 0.1, 0.05)
        
        pc1_range <- max(pc1_proj) - min(pc1_proj)
        if (pc1_range > 0) {
          pc1_scaled <- (pc1_proj - min(pc1_proj)) / pc1_range
        } else {
          pc1_scaled <- rep(0, length(pc1_proj))
        }
        within_cluster_time <- pc1_scaled * (1 / length(cluster_order))
        pseudotime[cluster_cells] <- base_time + within_cluster_time
      } else {
        pseudotime[cluster_cells] <- base_time
      }
    }
  }
  
  # Normalize pseudotime to 0-1
  pt_range <- max(pseudotime) - min(pseudotime)
  if (pt_range > 0) {
    pseudotime <- (pseudotime - min(pseudotime)) / pt_range
  } else {
    pseudotime <- rep(0.5, length(pseudotime))  # All cells get same pseudotime if no variation
  }
  
  # Create cellWeights (all cells belong to single lineage)
  cellWeights <- matrix(1, nrow = ncol(sce), ncol = 1)
  rownames(cellWeights) <- colnames(sce)
  colnames(cellWeights) <- "Lineage1"
  
  # Add pseudotime to SCE object
  colData(sce)$pseudotime <- pseudotime
  
  cat("Pseudotime range:", round(range(pseudotime), 3), "\n")
  
  # Step 4: Filter genes for TradeSeq
  cat("Filtering genes for analysis...\n")
  
  # Get count matrix - handle different assay types
  if ("counts" %in% assayNames(sce)) {
    counts_matrix <- assay(sce, "counts")
  } else if ("RNA" %in% assayNames(sce)) {
    counts_matrix <- assay(sce, "RNA")
  } else {
    counts_matrix <- assay(sce, 1)  # Use first assay
  }
  
  # Ensure counts are integer (some methods produce non-integer counts)
  if (!is.integer(counts_matrix[1,1])) {
    counts_matrix <- round(counts_matrix)
  }
  
  # Filter genes based on expression
  min_cells <- ceiling(ncol(sce) * min_cells_expressing)
  genes_expressed <- rowSums(counts_matrix > 0) >= min_cells
  
  # Keep genes with mean expression above threshold
  mean_expression <- rowMeans(counts_matrix)
  genes_mean_expr <- mean_expression >= min_gene_expression
  
  # Remove genes with zero variance
  gene_var <- apply(counts_matrix, 1, var)
  genes_nonzero_var <- gene_var > 0
  
  # Combine filters
  genes_keep <- genes_expressed & genes_mean_expr & genes_nonzero_var
  
  cat("Genes before filtering:", nrow(counts_matrix), "\n")
  cat("Genes after filtering:", sum(genes_keep), "\n")
  
  if (sum(genes_keep) < 10) {
    stop("Too few genes pass filtering criteria. Consider relaxing the thresholds.")
  }
  
  # Filter count matrix
  counts_filtered <- counts_matrix[genes_keep, ]
  
  # Step 5: Fit GAM models with TradeSeq
  cat("Fitting GAM models with TradeSeq...\n")
  cat("Using", n_knots, "knots per lineage\n")
  
  # Ensure pseudotime matrix is properly formatted
  pseudotime_matrix <- matrix(pseudotime, ncol = 1)
  colnames(pseudotime_matrix) <- "Lineage1"
  rownames(pseudotime_matrix) <- colnames(sce)
  
  # Fit the models with error handling
  tryCatch({
    sce_fit <- fitGAM(counts = counts_filtered,
                     pseudotime = pseudotime_matrix,
                     cellWeights = cellWeights,
                     nknots = n_knots,
                     verbose = TRUE,
                     parallel = FALSE)
  }, error = function(e) {
    stop(paste("GAM fitting failed:", e$message))
  })
  
  cat("GAM fitting complete!\n")
  
  # Step 6: Perform various TradeSeq tests
  cat("Performing TradeSeq statistical tests...\n")
  
  # Step 6a: Load gene annotations (if available)
  cat("Loading gene annotations...\n")
  annot_best <- NULL
  
  if (file.exists("/home/matthew/data/cluster_annotations.tsv")) {
    tryCatch({
      # Load the DIAMOND results
      annot <- read_tsv("/home/matthew/data/cluster_annotations.tsv", 
                       col_names = c("transcript_id", "sseqid", "pident", "evalue", "bitscore", "description"),
                       show_col_types = FALSE)
      
      # Clean DIAMOND output
      annot_clean <- annot %>%
        mutate(
          gene_id = str_extract(transcript_id, "g\\d+"),
          gene_symbol = str_extract(sseqid, "(?<=\\|)[A-Z0-9]+(?=_HUMAN)"),
          protein_name = str_remove(description, "sp\\|.*?\\|.*?_HUMAN\\s*")
        )
      
      # Keep best hit per gene
      annot_best <- annot_clean %>%
        group_by(gene_id) %>%
        slice_max(bitscore, n = 1, with_ties = FALSE) %>%
        ungroup()
      
      cat("Loaded annotations for", nrow(annot_best), "genes\n")
    }, error = function(e) {
      warning(paste("Failed to load annotations:", e$message))
      annot_best <- NULL
    })
  } else {
    cat("No annotation file found, using gene IDs only\n")
  }
  
  # Test 1: Association with pseudotime
  cat("Testing association with pseudotime...\n")
  tryCatch({
    assoc_res <- associationTest(sce_fit, lineages = TRUE)
    assoc_res$gene <- rownames(assoc_res)
    assoc_res <- assoc_res[order(assoc_res$pvalue), ]
    
    # Add gene annotations to association results
    if (!is.null(annot_best)) {
      assoc_res <- assoc_res %>%
        left_join(annot_best %>% select(gene_id, gene_symbol, protein_name), 
                  by = c("gene" = "gene_id")) %>%
        mutate(
          gene_name = ifelse(!is.na(gene_symbol), 
                            paste0(gene_symbol, " (", gene, ")"), 
                            gene),
          description = protein_name
        )
    } else {
      assoc_res$gene_name <- assoc_res$gene
      assoc_res$description <- NA
    }
  }, error = function(e) {
    warning(paste("Association test failed:", e$message))
    assoc_res <- data.frame()
  })
  
  # Test 2: Start vs end test
  cat("Testing start vs end differences...\n")
  tryCatch({
    start_end_res <- startVsEndTest(sce_fit, lineages = TRUE)
    start_end_res$gene <- rownames(start_end_res)
    start_end_res <- start_end_res[order(start_end_res$pvalue), ]
    
    # Add gene annotations to start vs end results
    if (!is.null(annot_best)) {
      start_end_res <- start_end_res %>%
        left_join(annot_best %>% select(gene_id, gene_symbol, protein_name), 
                  by = c("gene" = "gene_id")) %>%
        mutate(
          gene_name = ifelse(!is.na(gene_symbol), 
                            paste0(gene_symbol, " (", gene, ")"), 
                            gene),
          description = protein_name
        )
    } else {
      start_end_res$gene_name <- start_end_res$gene
      start_end_res$description <- NA
    }
  }, error = function(e) {
    warning(paste("Start vs end test failed:", e$message))
    start_end_res <- data.frame()
  })
  
  # Test 3: Pattern test (FIXED - only run if multiple lineages)
  pattern_res <- NULL
  n_lineages <- ncol(cellWeights)
  
  if (n_lineages > 1 && ("treatment_group" %in% colnames(colData(sce)) | "sample" %in% colnames(colData(sce)))) {
    cat("Testing for treatment-specific patterns...\n")
    
    tryCatch({
      # Create treatment variable
      if ("treatment_group" %in% colnames(colData(sce))) {
        treatment_var <- colData(sce)$treatment_group
      } else {
        # Create from samples
        treatment_var <- ifelse(colData(sce)$sample %in% c("C1", "C2"), "Control", "Regenerating")
      }
      
      # Pattern test comparing treatment groups
      pattern_res <- patternTest(sce_fit, global = TRUE, pairwise = TRUE)
      pattern_res$gene <- rownames(pattern_res)
      pattern_res <- pattern_res[order(pattern_res$pvalue), ]
      
      # Add gene annotations to pattern results
      if (!is.null(annot_best)) {
        pattern_res <- pattern_res %>%
          left_join(annot_best %>% select(gene_id, gene_symbol, protein_name), 
                    by = c("gene" = "gene_id")) %>%
          mutate(
            gene_name = ifelse(!is.na(gene_symbol), 
                              paste0(gene_symbol, " (", gene, ")"), 
                              gene),
            description = protein_name
          )
      } else {
        pattern_res$gene_name <- pattern_res$gene
        pattern_res$description <- NA
      }
    }, error = function(e) {
      warning(paste("Pattern test failed:", e$message))
      pattern_res <- NULL
    })
  } else {
    cat("Skipping pattern test - requires multiple lineages\n")
  }
  
  # Step 7: Create visualizations
  cat("Creating visualizations...\n")
  
  # Prepare plotting data
  plot_data <- data.frame(
    x = coords[,1],
    y = coords[,2],
    pseudotime = pseudotime,
    cluster = as.character(colData(sce)[[cluster_column]]),
    cell_id = colnames(sce)
  )
  
  # Add sample information if available
  if ("sample" %in% colnames(colData(sce))) {
    plot_data$sample <- colData(sce)$sample
  } else {
    plot_data$sample <- "Unknown"
  }
  
  # Add treatment groups
  if ("treatment_group" %in% colnames(colData(sce))) {
    plot_data$treatment_group <- colData(sce)$treatment_group
  } else {
    plot_data$treatment_group <- ifelse(plot_data$sample %in% c("C1", "C2"), "Control", "Regenerating")
  }
  
  # Colors
  n_clusters <- length(unique(plot_data$cluster))
  cluster_colors <- rainbow(n_clusters)
  names(cluster_colors) <- sort(unique(plot_data$cluster))
  
  sample_colors <- c("C1" = "#2166AC", "C2" = "#5AADE4", "R1" = "#D73027", "R2" = "#F46D43", "Unknown" = "#999999")
  treatment_colors <- c("Control" = "#0173B2", "Regenerating" = "#DE8F05")
  
  # Plot 1: Pseudotime on UMAP
  p1 <- ggplot(plot_data, aes(x = x, y = y, color = pseudotime)) +
    geom_point(size = 1, alpha = 0.8) +
    scale_color_viridis_c(name = "Pseudotime") +
    theme_minimal() +
    labs(title = paste("TradeSeq Pseudotime:", subset_name),
         x = paste(toupper(reduction), "1"),
         y = paste(toupper(reduction), "2"))
  
  # Plot 2: Clusters with pseudotime direction
  p2 <- ggplot(plot_data, aes(x = x, y = y, color = cluster)) +
    geom_point(size = 1, alpha = 0.7) +
    scale_color_manual(values = cluster_colors) +
    theme_minimal() +
    labs(title = paste("Clusters with Trajectory:", subset_name),
         x = paste(toupper(reduction), "1"),
         y = paste(toupper(reduction), "2"))
  
  # Add trajectory arrow
  cluster_centers_ordered <- plot_data %>%
    group_by(cluster) %>%
    summarise(
      x_center = mean(x),
      y_center = mean(y),
      mean_pseudotime = mean(pseudotime),
      .groups = 'drop'
    ) %>%
    arrange(mean_pseudotime)
  
  if (nrow(cluster_centers_ordered) > 1) {
    for (i in 1:(nrow(cluster_centers_ordered)-1)) {
      p2 <- p2 + annotate("segment",
                         x = cluster_centers_ordered$x_center[i],
                         y = cluster_centers_ordered$y_center[i],
                         xend = cluster_centers_ordered$x_center[i+1],
                         yend = cluster_centers_ordered$y_center[i+1],
                         arrow = arrow(length = unit(0.2, "cm")),
                         color = "black", linewidth = 1)
    }
  }
  
  # Plot 3: Treatment groups
  p3 <- ggplot(plot_data, aes(x = x, y = y, color = treatment_group)) +
    geom_point(size = 1, alpha = 0.7) +
    scale_color_manual(values = treatment_colors) +
    theme_minimal() +
    labs(title = paste("Treatment Groups:", subset_name),
         x = paste(toupper(reduction), "1"),
         y = paste(toupper(reduction), "2"))
  
  # Plot 4: Pseudotime distribution by cluster
  p4 <- ggplot(plot_data, aes(x = reorder(cluster, pseudotime, median), y = pseudotime, fill = cluster)) +
    geom_violin(alpha = 0.7) +
    geom_boxplot(width = 0.2, fill = "white", alpha = 0.8) +
    scale_fill_manual(values = cluster_colors) +
    theme_minimal() +
    labs(title = "Pseudotime Distribution by Cluster",
         x = "Cluster (ordered by median pseudotime)",
         y = "Pseudotime") +
    theme(legend.position = "none")
  
  # Plot 5: Top trajectory genes (with annotations)
  if (nrow(assoc_res) > 0) {
    top_genes <- head(assoc_res$gene[assoc_res$pvalue < 0.05], 9)
    
    if (length(top_genes) > 0) {
      plot_list <- list()
      
      # Get logcounts - handle different assay types
      if ("logcounts" %in% assayNames(sce)) {
        logcount_matrix <- assay(sce, "logcounts")
      } else {
        # Calculate log-normalized counts if not available
        logcount_matrix <- log1p(assay(sce, 1))
      }
      
      for (i in 1:length(top_genes)) {
        gene <- top_genes[i]
        if (gene %in% rownames(logcount_matrix)) {
          expr_data <- logcount_matrix[gene, ]
          plot_data$gene_expr <- expr_data
          
          # Get gene name for plot title
          gene_display_name <- assoc_res$gene_name[assoc_res$gene == gene][1]
          if (is.na(gene_display_name)) gene_display_name <- gene
          
          p_gene <- ggplot(plot_data, aes(x = pseudotime, y = gene_expr, color = treatment_group)) +
            geom_point(alpha = 0.5, size = 0.5) +
            geom_smooth(method = "gam", se = TRUE, formula = y ~ s(x, k = 4)) +
            scale_color_manual(values = treatment_colors) +
            theme_minimal() +
            labs(title = gene_display_name,
                 subtitle = paste("p =", format(assoc_res$pvalue[assoc_res$gene == gene], digits = 3)),
                 x = "Pseudotime",
                 y = "Expression") +
            theme(legend.position = "none",
                  plot.title = element_text(size = 10))
          
          plot_list[[i]] <- p_gene
        }
      }
      
      if (length(plot_list) > 0) {
        p5 <- patchwork::wrap_plots(plot_list, ncol = 3)
      } else {
        p5 <- ggplot() + ggtitle("No valid genes for plotting") + theme_void()
      }
    } else {
      p5 <- ggplot() + ggtitle("No significant trajectory genes found") + theme_void()
    }
  } else {
    p5 <- ggplot() + ggtitle("No trajectory genes to plot") + theme_void()
  }
  
  # Step 8: Create expression heatmap
  p6 <- NULL
  if (nrow(assoc_res) > 0) {
    cat("Creating expression heatmap...\n")
    
    tryCatch({
      # Get top 50 trajectory genes
      top_trajectory_genes <- head(assoc_res$gene[assoc_res$pvalue < 0.05], 50)
      
      if (length(top_trajectory_genes) > 5) {
        # Get expression data
        if ("logcounts" %in% assayNames(sce)) {
          expr_matrix <- assay(sce, "logcounts")[top_trajectory_genes, ]
        } else {
          expr_matrix <- log1p(assay(sce, 1))[top_trajectory_genes, ]
        }
        
        # Create gene labels with annotations
        gene_labels <- sapply(top_trajectory_genes, function(g) {
          gene_info <- assoc_res[assoc_res$gene == g, ]
          if (nrow(gene_info) > 0 && !is.na(gene_info$gene_symbol[1])) {
            return(paste0(gene_info$gene_symbol[1], " (", g, ")"))
          } else {
            return(g)
          }
        })
        
        rownames(expr_matrix) <- gene_labels
        
        # Order cells by pseudotime
        cell_order <- order(pseudotime)
        
        # Create pseudotime bins for visualization
        n_bins <- min(50, ncol(expr_matrix))
        bin_size <- ceiling(length(cell_order) / n_bins)
        
        binned_expr <- matrix(0, nrow = length(top_trajectory_genes), ncol = n_bins)
        rownames(binned_expr) <- gene_labels
        
        for (i in 1:n_bins) {
          start_idx <- (i-1) * bin_size + 1
          end_idx <- min(i * bin_size, length(cell_order))
          bin_cells <- cell_order[start_idx:end_idx]
          
          if (length(bin_cells) > 1) {
            binned_expr[, i] <- rowMeans(expr_matrix[, bin_cells])
          } else {
            binned_expr[, i] <- expr_matrix[, bin_cells]
          }
        }
        
        # Plot heatmap
        p6 <- pheatmap(binned_expr,
                cluster_rows = TRUE,
                cluster_cols = FALSE,
                scale = "row",
                show_colnames = FALSE,
                main = "Expression Heatmap",
                silent = TRUE)
      }
    }, error = function(e) {
      warning(paste("Heatmap creation failed:", e$message))
      p6 <- NULL
    })
  }
  
  # Step 9: Save results
  cat("Saving results...\n")
  
  # Create output directory if it doesn't exist
  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE)
  }
  
  # Create results summary
  results_summary <- list(
    n_cells = ncol(sce),
    n_genes_tested = nrow(counts_filtered),
    n_knots = n_knots,
    pseudotime_range = range(pseudotime)
  )
  
  if (nrow(assoc_res) > 0) {
    results_summary$n_trajectory_genes_p05 <- sum(assoc_res$pvalue < 0.05, na.rm = TRUE)
    results_summary$n_trajectory_genes_p01 <- sum(assoc_res$pvalue < 0.01, na.rm = TRUE)
  }
  
  # Save all results
  if (nrow(assoc_res) > 0) {
    write.csv(assoc_res, paste0(output_dir, subset_name, "_association_test.csv"), row.names = FALSE)
  }
  
  if (nrow(start_end_res) > 0) {
    write.csv(start_end_res, paste0(output_dir, subset_name, "_start_end_test.csv"), row.names = FALSE)
  }
  
  if (!is.null(pattern_res) && nrow(pattern_res) > 0) {
    write.csv(pattern_res, paste0(output_dir, subset_name, "_pattern_test.csv"), row.names = FALSE)
  }
  
  # Save trajectory data
  trajectory_data <- plot_data
  write.csv(trajectory_data, paste0(output_dir, subset_name, "_trajectory_data.csv"), row.names = FALSE)
  
  # Save plots with error handling
  tryCatch({
    combined_plots <- (p1 | p2) / (p3 | p4) / p5
    ggsave(paste0(output_dir, subset_name, "_tradeseq_analysis.png"), 
           combined_plots, width = 16, height = 18, dpi = 300)
  }, error = function(e) {
    warning(paste("Failed to save combined plots:", e$message))
  })
  
  if (!is.null(p6)) {
    tryCatch({
      ggsave(paste0(output_dir, subset_name, "_expression_heatmap.png"), 
             p6$gtable, width = 12, height = 10, dpi = 300)
    }, error = function(e) {
      warning(paste("Failed to save heatmap:", e$message))
    })
  }
  
  # Step 10: Print summary
  cat("\n=== TRADESEQ SUMMARY ===\n")
  cat("Total cells analyzed:", results_summary$n_cells, "\n")
  cat("Genes tested:", results_summary$n_genes_tested, "\n")
  cat("Knots used:", results_summary$n_knots, "\n")
  cat("Pseudotime range:", round(results_summary$pseudotime_range, 3), "\n")
  
  if ("n_trajectory_genes_p05" %in% names(results_summary)) {
    cat("Trajectory-associated genes (p < 0.05):", results_summary$n_trajectory_genes_p05, "\n")
    cat("Trajectory-associated genes (p < 0.01):", results_summary$n_trajectory_genes_p01, "\n")
  }
  
  if (nrow(start_end_res) > 0) {
    cat("Start vs End different genes (p < 0.05):", sum(start_end_res$pvalue < 0.05, na.rm = TRUE), "\n")
  }
  
  if (!is.null(pattern_res) && nrow(pattern_res) > 0) {
    cat("Pattern different genes (p < 0.05):", sum(pattern_res$pvalue < 0.05, na.rm = TRUE), "\n")
  }
  
  return(list(
    sce_fit = sce_fit,
    pseudotime = pseudotime,
    association_results = assoc_res,
    start_end_results = start_end_res,
    pattern_results = pattern_res,
    trajectory_data = trajectory_data,
    results_summary = results_summary,
    plots = list(p1, p2, p3, p4, p5, p6)
  ))
}

result1 <- perform_tradeseq_analysis(
  seurat_obj = seurat.deconv,
  subset_name = "muscle_plus16",
  target_clusters = c("2","13","18","16"),
  start_cluster = "16",
  n_knots = 6,
  reduction = "umap"
)
```
